function validate_task_model(GCM, PEB, name, SIM, infun, viz, DCM_fields)
%VALIDATE_TASK_MODEL Simulates, inverts, and validates DCM models.
%
% This function compares empirical PEB results to a validation PEB computed
% from simulation-based DCMs, inverted using simulated BOLD responses.
% These BOLD responses are generated by treating the inferred (empirical)
% DCM parameters and known (experimenter-controlled) inputs as ground
% truth. Regional observation error is added to simulated BOLD time series
% such that it matches the estimated signal-to-noise (SNR) ratio of the
% original (empirical) data.
% 
% The function optionally performs the within-function inversion of
% simulation-based DCMs using a parallel pool, and generates
% visualizations. If a given GCM is large, it may be prudent to use SLURM
% to invert the (yet-to-be-inverted) simulated models, which are saved to
% the working directory.
%
% INPUTS:
%   GCM   - Cell array of subject-level DCMs (empirically inverted)
%   PEB   - Empirical PEB structure (already estimated)
%   name  - Stub for file names
%   SIM   - (Optional) Simulated and inverted DCMs [default: []]
%   infun - (Optional) Invert simulated DCMs in function [default: true]
%   viz   - (Optional) Generate visualizations [default: true]
%   DCM_fields – (Optional) Flags which DCM fields should be compared 
%                           (between simulation-based and empirical models)
%                           [default: DCM_fields = PEB_fields]
%
% STEPS (if SIM is empty):
%   1. Simulate noise-free BOLD using spm_dcm_generate for each DCM.
%   2. Rescale each region’s simulated BOLD to match observed std.
%   3. Estimate SNR per region by computing signal-to-noise ratio 
%      from the residuals between observed and rescaled clean signal.
%   4. Add Gaussian noise scaled to match estimated tSNR per region.
%   5. Invert models (if infun is true), or save simulated DCMs.
%
% OUTPUT:
%   Saves validation PEB and (if requested) figures showing BOLD and 
%   parameter recovery comparisons.
%
% Author: Matthew Greaves 15-May-2025
% Updated: Matthew Greaves 16-Jun-2025 

% Set defaults
if nargin < 4 || isempty(SIM),          SIM = [];           end
if nargin < 5 || isempty(infun),        infun = true;       end
if nargin < 6 || isempty(viz),          viz = true;         end
if nargin < 7 || isempty(DCM_fields),   DCM_fields = [];    end

if isempty(SIM)
    DCM = cell(size(GCM));
    for i = 1:numel(GCM)

        % Correct for log-normal priors (and other parameterization quirks)
        % GCM{i} = adjust_parameters(GCM{i});

        % Simulate BOLD given infered paramaters and known inputs
        [sig, ~, DCM{i}] = spm_dcm_generate(GCM{i},...
            inf, false);
        Y_clean = sig.y;

        % Rescale simulated responses to match observed responses
        Y_obs = GCM{i}.Y.y;
        scale_factors = std(Y_obs, 0, 1) ./ std(Y_clean, 0, 1);
        Y_clean_rescaled = Y_clean .* scale_factors;

        % Estimate region-specific SNR from standard deviation of residual
        residual = Y_obs - Y_clean_rescaled;
        tsnr = std(Y_clean_rescaled, 0, 1) ./ std(residual, 0, 1);

        % Use SNR to simulate realistic noise
        noise_sd = std(Y_clean_rescaled, 0, 1) ./ tsnr;
        Y_simulated = Y_clean_rescaled +...
            randn(size(Y_clean_rescaled)) .* noise_sd;

        % Optional: rescale final simulated BOLD to match observed std
        scale_factors_sim = std(Y_obs, 0, 1) ./ std(Y_simulated, 0, 1);
        Y_simulated = Y_simulated .* scale_factors_sim;

        % Update simulated model
        DCM{i}.Y.y = Y_simulated;

        % Generate optional visual for first subject
        if viz && i == 1
            h = plot_sub_responses(Y_obs, Y_clean_rescaled, Y_simulated);

            % Save MATLAB figure
            saveas(h, ['bold_response_comparison_', name, '.fig']);
        end
    end

    % Invert models within-function (using `parfor`) or else save simulated
    % subjects (for out-of-function parallel inversion)
    if infun

        % Clean up any existing parallel pool
        delete(gcp('nocreate'));

        % Start parallel pool
        parpool('local');
 
        P = cell(size(DCM));
        parfor i = 1:numel(P)
            fprintf('\n\nInverting instantiation: %.0f\n', i);
            ins  = spm_dcm_fit(DCM{i})
            P{i} = ins{1};
        end
        default_output = ['DCM-', char(datetime('today')), '.mat'];
        if exist(default_output, "file")
            delete(default_output);
        end

        % Shut down the parallel pool
        delete(gcp('nocreate'));

        % Save inverted models
        SIM = P;
        save(['inverted_simulations_', name,...
            char(datetime('today'))], "SIM")

    else
        % Save (yet-to-be-inverted) simulated models
        save(['simulations_', name, char(datetime('today'))], "DCM")
    end
else
    % Utilise pre-saved models in (validation) PEB
    P = SIM;
end

% Invert (validation) PEB
PEB_fields = unique(cellfun(@(x) regexp(x, '^[^\(]+', 'match',...
    'once'), PEB.Pnames, 'UniformOutput', false)).';
[vPEB, ~]   = spm_dcm_peb(P, PEB.M, PEB_fields);

% Calculate and print RMSE and correlation
group_rmse  = sqrt(mean((full(PEB.Ep)-full(vPEB.Ep)).^2));
group_rho   = corr(full(PEB.Ep), full(vPEB.Ep));

%--------------------------------------------------------------------------
fprintf('PEB vs validation:\n');
fprintf('  RMSE        = %.4f\n', group_rmse);
fprintf('  Correlation = %.3f\n', group_rho);
%--------------------------------------------------------------------------

% Select DCM fields to examine
if isempty(DCM_fields)
    DCM_fields = PEB_fields;
elseif all(ismember(DCM_fields, 'all'))
    DCM_fields = fieldnames(GCM{1}.Ep);
else
    assert(any(contains(fieldnames(GCM{1}.Ep), DCM_fields)),...
        'Failed to find specified parameter(s)...');
end

% Calculate correlation at subject level
sub_rho = nan(size(P));
for i = 1:numel(P)

    % Correct for log-normal priors (and other parameterization quirks)
    P{i} = adjust_parameters(P{i});
    GCM{i} = adjust_parameters(GCM{i});

    Tp_cell = cell(1, numel(DCM_fields));
    Ep_cell = cell(1, numel(DCM_fields));

    for j = 1:numel(PEB_fields)
        Tp_cell{j} = full(spm_vec(GCM{i}.Ep.(DCM_fields{j})));
        Ep_cell{j} = full(spm_vec(P{i}.Ep.(DCM_fields{j})));
    end

    Tp = vertcat(Tp_cell{:});
    Ep = vertcat(Ep_cell{:});

    sub_rho(i) = corr(Tp, Ep);
end

% Generate optional visual for first subject
if viz
    g = plot_results(full(PEB.Ep), full(vPEB.Ep), group_rmse, group_rho,...
        sub_rho);

    % Save MATLAB figure
    saveas(g, ['results_figure_', name, '.fig']);
end

% Save (validation) PEB
save(['validation_PEB_', name, char(datetime('today'))], "vPEB");

end

%--------------------------------------------------------------------------
% Correct for log-normal priors over DCM parameters
%--------------------------------------------------------------------------

function DCM = adjust_parameters(DCM)

Ep      = DCM.Ep;
fields  = fieldnames(Ep);
for i = 1:numel(fields)
    param_name = fields{i};
    P = Ep.(param_name);
    switch param_name
        case 'A'
            n = sqrt(numel(P));
            P(logical(eye(n))) = -0.5 * exp(diag(P));
        case 'B'
            for k = 1:size(P,3)
                B = P(:,:,k);
                n = sqrt(numel(B));
                B(logical(eye(n))) = -0.5 * exp(diag(B));
                P(:,:,k) = B;
            end
        case 'C'
            P = 1/16*P;
        case 'D'
            % Do nothing. This part of the code can be updated should
            % someone wish to make use of non-linear interactions.
        case 'transit'
            % Do nothing. Not sure that this should be altered.
            % P = 2*exp(P);
        case 'decay'
            % Do nothing. Not sure that this should be altered.
            % P = 0.64*exp(P);
        case 'epsilon'
            % Do nothing. Not sure that this should be altered.
            % P = exp(P);
    end        
    Ep.(param_name) = P;
end

DCM.Ep = Ep;

end

%--------------------------------------------------------------------------
% Plot coorelation with empirical PEB results and parameter recovery (DCM)
%--------------------------------------------------------------------------

function h = plot_results(Tp, Ep, group_rmse, group_rho, sub_rho)

% Create figure
h = figure;
set(h, 'Units', 'normalized', 'OuterPosition', [0 1 1 1/2]);
xy_ax = max(1, ceil(max(abs([Tp(:); Ep(:)]))));

% 1. PEB models
ax_a = subplot(1,2,1);
scatter(Tp(:), Ep(:), 150, 'g', 'filled');
hold on;
plot([-xy_ax, xy_ax], [-xy_ax, xy_ax], 'k--', 'LineWidth', 1.2);
ylim([-xy_ax, xy_ax]);
xlim([-xy_ax, xy_ax]);
grid on;
title('PEB recovery')
xlabel('True group-level parameters');
ylabel('MAP group-level estimates');
set(findall(gcf, '-property', 'FontSize'), 'FontSize', 16);

% Add RMSE and correlation as top-left annotation
annotation_str = sprintf('RMSE: %.3f\nr: %.3f', group_rmse, group_rho);
axes(ax_a);
x_pos = 0.02;
y_pos = 0.98;
text(x_pos, y_pos, annotation_str, ...
    'Units', 'normalized', ...
    'HorizontalAlignment', 'left', ...
    'VerticalAlignment', 'top', ...
    'FontSize', 14, ...
    'FontWeight', 'normal');

% 2. DCM models
subplot(1,2,2);
bar(sub_rho);
title('DCM recovery')
xlabel('Instantiation (simulated subject)');
ylabel('Pearson''s \it{r}');
set(findall(gcf, '-property', 'FontSize'), 'FontSize', 16);

end

%--------------------------------------------------------------------------
% Plot example clean, empirical and noise-injected time series
%--------------------------------------------------------------------------

function h = plot_sub_responses(Y_obs, Y_clean_rescaled, Y_simulated)

% Create figure
h = figure;
set(h, 'Units', 'normalized', 'OuterPosition', [1/5 1 1/2 4/5]);
T = size(Y_clean_rescaled, 1);
y_max = ceil(max(abs(Y_obs(:))));

% 1. Noisy observed BOLD
subplot(3,1,1);
plot(Y_obs);
title('Observed (noisy) BOLD');
ylabel('Amplitude (arb.)');
ylim([-y_max, y_max]);
xlim([1 T]);
set(findall(gcf, '-property', 'FontSize'), 'FontSize', 16);


% 2. Clean simulated BOLD
subplot(3,1,2);
plot(Y_clean_rescaled);
title('Clean simulated BOLD');
ylabel('Amplitude (arb.)');
ylim([-y_max, y_max]);
xlim([1 T]);
set(findall(gcf, '-property', 'FontSize'), 'FontSize', 16);


% 3. Simulated BOLD with noise
subplot(3,1,3);
plot(Y_simulated);
title('Simulated BOLD with region-specific noise');
xlabel('Time');
ylabel('Amplitude (arb.)');
ylim([-y_max, y_max]);
xlim([1 T]);
set(findall(gcf, '-property', 'FontSize'), 'FontSize', 16);


% Optional: improve layout
sgtitle('Comparison of BOLD Responses', 'FontSize', 18);  % overall title

end